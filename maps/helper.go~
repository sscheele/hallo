package gmaps

import (
	"bufio"
	"io/ioutil"
	"net/http"
	"os"
	"strings"
)

var apiKey string

//InitAPIKey reads in the API key from the default file
func InitAPIKey() error {
	f, err := os.Open("api-key.txt")
	if err != nil {
		return err
	}
	reader := bufio.NewReader(f)
	apiKey, err = reader.ReadString('\n')
	if err != nil {
		return err
	}
	apiKey = apiKey[:len(apiKey)-1]
	return nil
}

//GetTimeToLocation is given an origin, destination, target arrival time, and, optionally, points to avoid
//it returns the estimated time, in seconds
func GetTimeToLocation(params map[string]string) int {
	respBody := getDirs(params)
	return getTripLen(respBody)
}

//returns the trip length in seconds
func getTripLen(respBody string) int {
	//LOOK FOR "travelDurationTraffic"
	traff := strings.LastIndex(respBody, "travelDurationTraffic")
	noTraff := strings.LastIndex(respBody, "travelDuration")
	return respBody //TODO: ACTUALLY DO THIS
}

func getDirs(params map[string]string) string {
	params["key"] = apiKey //shave off trailing newline
	params["optimize"] = "timeWithTraffic"

	client := &http.Client{}
	req, err := http.NewRequest("GET", "http://dev.virtualearth.net/REST/v1/Routes", nil)
	if err != nil {
		return ""
	}
	q := req.URL.Query()
	for key, value := range params {
		q.Add(key, value)
	}
	req.URL.RawQuery = q.Encode()
	resp, err := client.Do(req)
	if err != nil {
		return ""
	}
	respBody, _ := ioutil.ReadAll(resp.Body)

	return string(respBody)
}
